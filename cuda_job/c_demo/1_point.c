#include<stdio.h>


void spw(int *a, int *b)
{
    int tmp;
    tmp = *a;
    *a = *b;
    *b = tmp;
}

int main()
{
    int x, y, z;
    scanf("%d%d%d", &x, &y, &z);
    if (x > y)
        spw(&x, &y);
    if(x > z)
        spw(&x, &z);
    if(y > z)
        spw(&y, &z);
    printf("small to big: %d %d %d\n", x, y, z);
}

// 这时候奇怪的事情发生了，刚才内存中交换的值又变回来了？这是为什么呢？在这里就不得不说在C语言中关于局部变量的问题，局部变量在C语言中是没有固定的存储位置的，它是由系统的堆栈统一来管理的，当进入函数内部时，系统就会给这些局部变量临时分配一个存储空间存储它的值，当程序要离开函数时，系统就会将局部变量的值保存在堆栈中，然后变量的存储位置就被释放了。当程序进入另一个函数中时，又会给这个函数内部局部变量分配空间，这时候可能就会出现两个函数中的局部变量都使用了同一个内存空间。此时这个内存空间的值改变后，并不影响上一个函数中局部变量的值，因为上一个函数中的局部变量值此时在堆栈中存放。当程序要离开当前的这个函数时，又会将当前的局部变量值保存在堆栈中。回到上一个函数后，又将堆栈中存储的值恢复给变量，此时变量的地址又是临时申请的，可能此刻申请的地址值还是和上一次一样。但是并不代表这个地址就永远属于这个局部变量。
// 这个就很类似于超市中的储物柜，你要进去超市买东西，先将东西存到一个柜子中，买完东西后，又将东西存储物柜取了出来。然后隔了几个小时，又要去这个超市买东西，又需要将东西存起来，但是此时存储的柜子编号还是上上一次存储时一样。但是这并不能代表这个柜子的编号就是专属于你的了。它只是储物柜临时分配给你的空间，当你取出东西后这个空间就会被系统收回，如果你下一次还需要用，系统又会自动给你分配，但是这两次分配的刚好是一个编号而已。
// 那么要如何解决这种变量交换的问题呢？有两种方法，第一种就是直接将要交换的这个两个变量定义为全局变量，让它在程序运行的过程中独占一个地址空间，这样就不会有其他变量来使用这个位置了。但是这样的话就会比较浪费内存空间，只使用了一次，但是却要永久的占用。第二种方法就是直接使用指针。